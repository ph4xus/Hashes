<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bitcoin Hash Calculator (Free API)</title>
    <style>
        body { margin:0; padding:0; background:linear-gradient(120deg, #090a0f 0%, #06141d 100%); min-height:100vh; }
        .container {
            background: rgba(14, 25, 33, 0.94);
            max-width: 560px;
            margin: 40px auto 25px auto;
            border-radius: 18px;
            box-shadow: 0 0 32px #16ffb833, 0 0 1.2em #014529;
            padding: 2.3em 2em 1.9em 2em;
            border: 2.8px solid #01d88f88;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        h1 {
            color: #26ffe2;
            text-shadow: 0 0 8px #1affd588, 0 0 14px #1af9ca;
            font-family: inherit;
            font-size: 2.2em;
            margin-top: 0; margin-bottom: 0.5em;
            text-align: center;
        }
        .toggle-wrap {
            margin: 1.1em 0 1.8em 0;
            text-align: center; }
        .toggle-label {
            background: #162a21;
            color: #1affd5;
            padding: 0.41em 1.17em 0.41em 0.85em;
            border-radius: 4px;
            border: 1px solid #29e88779;
            box-shadow: 0 0 5px #14ff9588 inset;
            margin-left: 8px;
            transition: border-color 0.18s;
        }
        label, input[type="checkbox"] {
            cursor: pointer;
            font-size: 1em;
            user-select: none;
        }
        input[type="checkbox"] { transform: scale(1.32); margin-right:6px;}
        button {
            background: #122d18;
            border: 2px solid #41d97c;
            color: #41ff9c;
            font-size: 1.13em;
            letter-spacing: 0.05em;
            padding: 0.55em 2.15em;
            border-radius: 7px;
            box-shadow: 0 0 14px #14ef90b7;
            cursor: pointer;
            transition: .17s;
            margin: 0 auto 1.5em auto;
            display: block;
        }
        button:hover, button:active {
            background: #234d1d;
            border-color: #4effd8;
            color: #a1ffe7;
            box-shadow: 0 0 16px #41ef70;
        }
        .panel {
            background: #101918dc;
            border-radius: 9px;
            border-left: 3.2px solid #37ffc7cc;
            border-right: 2.6px solid #26ffaa21;
            box-shadow: 0 0 1.3em #17ffb214, 0 0 0.4em #1ed3822a;
            margin-bottom: 1.25em;
            padding: 1.1em 1em 1.1em 1.3em;
        }
        h3 {
            color: #59ffe4;
            font-size: 1.07em;
            border-left: 3px solid #02ef90;
            padding-left: 12px;
            margin: 0.65em 0 0.85em;
            text-shadow: 0 0 6px #09b9a0;
        }
        .stats-area {
            background: #162d17e4;
            color: #6ffd89;
            border-radius: 7px;
            font-family: inherit;
            letter-spacing: 0.2px;
            padding: 0.95em 1.2em 1.1em 1em;
            font-size: 1em;
            border: 1px solid #19ffb972;
            margin-bottom:.9em; margin-top:1.3em;
            box-shadow: 0 0 0.5em #1fff9588 inset;
        }
        .statrow { display: flex; flex-wrap:wrap; margin-bottom: 2px; }
        .statlabel {
            min-width: 120px;
            color: #41ffe3; margin-right: 1.4em;
        }
        .statval {
            font-family: inherit;
            font-weight: bold;
            color: #b0ffc7;
            text-shadow: 0 0 5px #19f7c144;
        }
        textarea, #status, #foundHash {
            background-color: #0b161b !important;
            color: #48ffdd;
            font-size: 1em;
            border-radius: 6px;
            border: 1.5px solid #21e04d77;
            padding: 0.7em;
            box-shadow: 0 0 0.95em #0cdb7099 inset;
            font-family: inherit;
            width: 98%;
            margin: 2px 0 9px 0;
            outline: none;
            transition: border-color 0.20s, box-shadow 0.2s;
        }
        textarea:focus, #foundHash:focus, #status:focus {
            border-color: #39ffb7 !important;
            box-shadow: 0 0 0.35em #13fff1c7, 0 0 0.65em #09ff6c3e;
        }
        textarea[readonly] {
            resize: none;
            opacity: 0.97;
        }
        #status {
            font-weight: bold;
            color: #08fbdc;
            border-left: 4.5px solid #44fcd1;
            box-shadow: none;
            border-top: none; border-bottom: none; border-right: none;
            padding-left: 1.2em; margin-bottom: 13px;
            background: #0d2127e8 !important;
            min-height: 2.2em;
        }
        .success { color: #88ff90 !important; text-shadow: 0 0 10px #54ffb9e4; }
        .error   { color: #ff4261 !important; border-color: #ff4261 !important; text-shadow: 0 0 4px #ff4261; }
        #foundHash { font-size: 1.04em; color: #30ffb3; word-break: break-all; margin:0;}
        ::selection { background: #33ffc733; }
        ::-webkit-scrollbar { width: 9px; background: #1d242c;}
        ::-webkit-scrollbar-thumb { background: #088e5c; border-radius: 7px;}
        @media (max-width: 600px) {
            .container { padding: 1.3em 0.6em; }
            .panel { padding: 0.7em 0.5em 0.8em 0.7em;}
            .stats-area { font-size:0.97em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bitcoin Hash Calculator</h1>
        <div class="toggle-wrap">
            <input id="toggleNonceWindow" type="checkbox" checked>
            <label class="toggle-label" for="toggleNonceWindow">Show Nonce Log Window (slower)</label>
        </div>
        <button onclick="startMining()">Start Hash Calculation</button>
        <div class="panel">
            <h3>Latest Block Header Data:</h3>
            <textarea id="blockHeader" readonly rows="6"></textarea>
        </div>
        <div class="panel">
            <div class="stats-area" id="miningStats">
                <div class="statrow"><span class="statlabel">Nonces tried:</span><span class="statval" id="stat_nonces">0</span></div>
                <div class="statrow"><span class="statlabel">Elapsed time:</span><span class="statval" id="stat_secs">0.00s</span></div>
                <div class="statrow"><span class="statlabel">Hashes/sec:</span><span class="statval" id="stat_speed">0</span></div>
                <div class="statrow"><span class="statlabel">Lowest hash:</span><span class="statval" id="stat_lowest"></span></div>
            </div>
            <h3>Calculation Status:</h3>
            <div id="status"></div>
        </div>
        <div class="panel">
            <h3>Found Hash:</h3>
            <p id="foundHash"></p>
        </div>
    </div>
    <script>
        // --- Typing effect utility ---
        async function typeText(elem, text, delay=15, append=false) {
            // Clear or setup
            if (!append) elem.textContent = '';
            for (let i = 0; i < text.length; i++) {
                elem.textContent += text[i];
                await new Promise(res => setTimeout(res, delay));
            }
        }

        // --- Log pop-up window styling ---
        const logWinStyle = `<style>
            body { background: #0b1017; color:#6cffd0; font-family: monospace; font-size: 1em; margin:0.2em 0.6em;}
            h2 { color: #1affd5; text-shadow: 0 0 10px #3afff388; border-bottom: 1.6px solid #17d99e44; }
            #log { width:100%; height:70vh; overflow-y:auto; background:#08141d; padding:0.8em 0.7em; border-radius:6px; box-shadow:0 0 8px #13ffce2a inset;}
            .found { color:#1aff29 !important; font-weight:bold; text-shadow:0 0 4px #b3ffca;}
            ::-webkit-scrollbar { width:9px; background:#071614;}
            ::-webkit-scrollbar-thumb { background:#29ffdb88;}
        </style>`;
        function scrollToBottomLog(logDiv) {
            if (!logDiv) return;
            logDiv.scrollTop = logDiv.scrollHeight + 1000;
            const last = logDiv.lastElementChild;
            if (last) last.scrollIntoView({behavior: "instant", block:"end"});
        }
        function hexToBytes(hex) {
            if (hex.length % 2 !== 0) throw new Error("Hex string must have even length!");
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        }
        function bytesToHex(arr) {
            return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
        }
        function toLittleEndian(hex) {
            return hex.match(/../g).reverse().join('');
        }
        async function getLatestBlockHeader() {
            const chainInfoResp = await fetch('https://api.blockcypher.com/v1/btc/main');
            if (!chainInfoResp.ok) throw new Error('Could not fetch latest block hash');
            const chainInfo = await chainInfoResp.json();
            const blockHash = chainInfo.hash;
            const blockResp = await fetch('https://api.blockcypher.com/v1/btc/main/blocks/' + blockHash);
            if (!blockResp.ok) throw new Error('Could not fetch latest block data');
            const data = await blockResp.json();
            for (const key of ['ver', 'prev_block', 'mrkl_root', 'bits', 'time']) {
                if (data[key] === undefined || data[key] === null) {
                    throw new Error(`BlockCypher API missing ${key}. Block data: ${JSON.stringify(data, null, 2)}`);
                }
            }
            const unixTime = Math.floor(new Date(data.time).getTime() / 1000);
            return {
                ver: data.ver,
                prev_block: data.prev_block,
                mrkl_root: data.mrkl_root,
                time: unixTime,
                bits: data.bits,
                nonce: 0
            };
        }
        function bitsToTarget(bits) {
            let exponent = bits >>> 24;
            let mantissa = bits & 0xffffff;
            let target = BigInt(mantissa) * (2n ** (8n * (BigInt(exponent) - 3n)));
            return target;
        }
        function serializeBlockHeader(header) {
            for (let key of ['ver', 'prev_block', 'mrkl_root', 'time', 'bits', 'nonce']) {
                if (header[key] === undefined || header[key] === null) {
                    throw new Error(`Header field ${key} is undefined! Value: ` + header[key]);
                }
            }
            let hex = ''
                + toLittleEndian(header.ver.toString(16).padStart(8, '0'))
                + toLittleEndian(header.prev_block)
                + toLittleEndian(header.mrkl_root)
                + header.time.toString(16).padStart(8, '0')
                + header.bits.toString(16).padStart(8, '0')
                + header.nonce.toString(16).padStart(8, '0');
            return hexToBytes(hex);
        }
        async function doubleSHA256(buffer) {
            let hash1 = await crypto.subtle.digest('SHA-256', buffer);
            let hash2 = await crypto.subtle.digest('SHA-256', hash1);
            return bytesToHex(new Uint8Array(hash2));
        }

        // ========= Mining & logging logic ==========
        let logWin = null;
        let nonceLogOn = true;
        function openLogWindow() {
            if (!nonceLogOn) return;
            if (logWin && !logWin.closed) { logWin.focus(); return logWin; }
            logWin = window.open('', 'NonceLog', 'width=560,height=660,scrollbars');
            logWin.document.write(
                '<!DOCTYPE html><title>Nonce Log</title>' + logWinStyle +
                '<body><h2>Mining Log</h2><div id="log"></div></body>'
            );
            logWin.document.close();
            logWin.logDiv = logWin.document.getElementById('log');
            return logWin;
        }
        function logNonce(nonce, hash, found) {
            if (!nonceLogOn || !logWin || logWin.closed) return;
            logWin.logDiv.insertAdjacentHTML('beforeend',
                `<span${found ? ' class="found"' : ''}>${nonce}${hash ? ` : ${hash}` : ''}</span><br>`);
            scrollToBottomLog(logWin.logDiv);
        }
        function clearLogWindow() {
            if (!logWinOn() || !logWin || logWin.closed) return;
            logWin.logDiv.innerHTML = '';
        }
        function closeLogWindow() {
            if (logWin && !logWin.closed) logWin.close();
        }
        function logWinOn() { return nonceLogOn; }
        document.getElementById('toggleNonceWindow').addEventListener('change', function(e) {
            nonceLogOn = e.target.checked;
            if (!nonceLogOn) closeLogWindow();
        });

        // ---- Mining stats ---
        let miningStats = {
            startTimestamp: 0,
            elapsed: 0,
            tried: 0,
            speed: 0,
            lowestHash: null
        };
        let statsInterval = null;
        function resetStats() {
            miningStats = {startTimestamp: 0, elapsed: 0, tried: 0, speed: 0, lowestHash: null};
            updateStatsPanel();
        }
        function updateStatsPanel() {
            document.getElementById('stat_nonces').textContent = miningStats.tried.toLocaleString();
            document.getElementById('stat_secs').textContent = miningStats.elapsed.toFixed(2) + "s";
            document.getElementById('stat_speed').textContent = miningStats.speed.toLocaleString();
            document.getElementById('stat_lowest').textContent = miningStats.lowestHash ? miningStats.lowestHash : "(none)";
        }
        function startStatsTicker() {
            if (statsInterval) clearInterval(statsInterval);
            statsInterval = setInterval(() => {
                if (miningStats.startTimestamp)
                    miningStats.elapsed = (performance.now() - miningStats.startTimestamp)/1000;
                if (miningStats.elapsed > 0)
                    miningStats.speed = Math.floor(miningStats.tried / miningStats.elapsed);
                updateStatsPanel();
            }, 200);
        }
        function endStatsTicker() {
            if (statsInterval) clearInterval(statsInterval);
            statsInterval = null;
        }

        async function startMining() {
            nonceLogOn = document.getElementById('toggleNonceWindow').checked;
            if (nonceLogOn) { openLogWindow(); if (logWin && !logWin.closed) logWin.logDiv.innerHTML = ''; }
            else closeLogWindow();
            // Typing effect clears output
            const statusDiv = document.getElementById('status');
            const foundHashP = document.getElementById('foundHash');
            const blockHeaderTextarea = document.getElementById('blockHeader');
            resetStats();
            statusDiv.className = '';
            await typeText(statusDiv, 'Fetching latest block data...');
            foundHashP.textContent = '';
            try {
                const header = await getLatestBlockHeader();
                await typeText(blockHeaderTextarea, JSON.stringify(header, null, 2), 2);
                await new Promise(res=>setTimeout(res,200));
                await typeText(statusDiv, 'Data fetched. Beginning hash calculation...');
                const target = bitsToTarget(header.bits);

                let nonce = 0, stop = false;
                miningStats.startTimestamp = performance.now();
                miningStats.elapsed = 0;
                miningStats.tried = 0;
                miningStats.speed = 0;
                miningStats.lowestHash = null;
                updateStatsPanel();
                startStatsTicker();

                async function mineChunk() {
                    if (nonceLogOn) openLogWindow();
                    for (let i = 0; i < 100000 && !stop; ++i, ++nonce) {
                        header.nonce = nonce;
                        let raw = serializeBlockHeader(header);
                        let hashHex = await doubleSHA256(raw);
                        let reversedHash = toLittleEndian(hashHex);
                        let hashNum = BigInt('0x' + reversedHash);
                        logNonce(nonce, reversedHash, hashNum < target);

                        // lowest hash stats
                        if (miningStats.lowestHash === null || hashNum < BigInt('0x'+miningStats.lowestHash)) {
                            miningStats.lowestHash = reversedHash;
                        }
                        miningStats.tried = nonce;

                        if (hashNum < target) {
                            endStatsTicker();
                            statusDiv.className = 'success';
                            await typeText(statusDiv, `Success! Valid hash found at nonce: ${nonce.toLocaleString()}`, 16);
                            await typeText(foundHashP, reversedHash, 4);
                            if (nonceLogOn) logNonce(nonce, reversedHash, true);
                            updateStatsPanel();
                            return;
                        }
                        if (nonce % 1000 === 0) {
                            statusDiv.className = '';
                            await typeText(statusDiv, `Mining chunk... Nonce: ${nonce.toLocaleString()}`, 1, false);
                        }
                    }
                    if (!stop) {
                        endStatsTicker();
                        updateStatsPanel();
                        let cont = confirm(`Searched ${nonce.toLocaleString()} nonces. Continue mining next 100,000?`);
                        if (cont) {
                            miningStats.startTimestamp = performance.now() - miningStats.elapsed*1000;
                            startStatsTicker();
                            mineChunk();
                        } else {
                            statusDiv.textContent = `Stopped at nonce ${nonce.toLocaleString()}.`;
                            statusDiv.className = '';
                        }
                    }
                }
                mineChunk();
            } catch (error) {
                endStatsTicker();
                statusDiv.textContent = 'Error: ' + error.message;
                statusDiv.className = 'error';
            }
        }
    </script>
</body>
</html>