<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bitcoin Miner</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            font-family: 'Share Tech Mono', monospace; 
            overflow-x: hidden; 
            color: #ffffff;
        }
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
            background: repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, transparent 2px);
            pointer-events: none; animation: scanline 8s linear infinite;
        }
        @keyframes scanline { 0% { transform: translateY(0); } 100% { transform: translateY(50px); }}
        .matrix-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: radial-gradient(circle at 50% 50%, #0a0a0a 0%, #000000 100%);
        }
        .container {
            position: relative; z-index: 2;
            background: rgba(10, 10, 10, 0.95);
            max-width: 95%;
            margin: 20px auto;
            border-radius: 0;
            box-shadow: 0 0 40px #ffffff22, 0 0 80px #ffffff11, inset 0 0 60px #11111111;
            padding: 1.5em;
            border: 1px solid #ffffff;
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-gap: 20px;
        }
        @media (max-width: 1200px) { 
            .container { 
                grid-template-columns: 1fr; 
            } 
        }
        h1 {
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff88, 0 0 30px #ffffff44;
            font-size: 1.8em;
            margin: 0 0 0.3em 0;
            text-align: center;
            letter-spacing: 4px;
            text-transform: uppercase;
            border-bottom: 2px solid #ffffff;
            padding-bottom: 0.3em;
            animation: flicker 3s infinite alternate;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            41%, 43% { opacity: 0.9; }
            45% { opacity: 1; }
        }
        .subtitle {
            text-align: center; 
            color: #cccccc; 
            opacity: 0.8;
            font-size: 0.75em; 
            letter-spacing: 2px; 
            margin-bottom: 1.5em;
        }
        .left-panel { display: flex; flex-direction: column; gap: 15px; }
        .right-panel { display: flex; flex-direction: column; gap: 15px; }
        .nonce-stream {
            background: #000; 
            border: 1px solid #888888;
            border-radius: 0; 
            padding: 10px; 
            height: 400px; 
            overflow-y: auto;
            font-size: 0.8em; 
            color: #cccccc;
            box-shadow: inset 0 0 20px #11111111;
        }
        .nonce-stream::-webkit-scrollbar { width: 6px; background: #111111; }
        .nonce-stream::-webkit-scrollbar-thumb { background: #666666; }
        .nonce-line { 
            opacity: 0.7; 
            margin: 2px 0; 
            font-family: 'Share Tech Mono', monospace; 
        }
        .nonce-line.found { 
            color: #ffffff; 
            opacity: 1; 
            font-weight: bold; 
            animation: pulse 0.5s; 
        }
        @keyframes pulse { 
            0%, 100% { opacity: 1; } 
            50% { opacity: 0.5; } 
        }
        button {
            background: #000;
            border: 2px solid #ffffff;
            color: #ffffff;
            font-size: 1em;
            letter-spacing: 3px;
            padding: 0.7em 2em;
            border-radius: 0;
            box-shadow: 0 0 20px #ffffff44;
            cursor: pointer;
            transition: .15s;
            font-family: 'Share Tech Mono', monospace;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        button:before {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: -100%; 
            width: 100%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, #ffffff22, transparent);
            transition: left 0.5s;
        }
        button:hover:before { left: 100%; }
        button:hover, button:active {
            background: #222222;
            border-color: #ffffff;
            color: #ffffff;
            box-shadow: 0 0 30px #ffffff66;
        }
        .panel {
            background: rgba(15, 15, 15, 0.9);
            border-radius: 0;
            border: 1px solid #666666;
            box-shadow: 0 0 15px #ffffff11, inset 0 0 30px #11111105;
            padding: 12px;
            position: relative;
        }
        .panel:before {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0;
            height: 1px; 
            background: linear-gradient(90deg, transparent, #888888, transparent);
        }
        h3 {
            color: #ffffff;
            font-size: 0.9em;
            border-left: 3px solid #ffffff;
            padding-left: 10px;
            margin: 0 0 10px 0;
            text-shadow: 0 0 10px #ffffff44;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        .stat-box {
            background: #000;
            border: 1px solid #666666;
            padding: 10px;
            text-align: center;
            box-shadow: inset 0 0 10px #11111111;
        }
        .stat-label {
            color: #aaaaaa;
            font-size: 0.7em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }
        .stat-value {
            color: #ffffff;
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 0 0 10px #ffffff44;
            margin-top: 5px;
        }
        .chart-container {
            background: #000;
            border: 1px solid #666666;
            padding: 10px;
            height: 150px;
            position: relative;
            overflow: hidden;
        }
        #hashRateChart {
            width: 100%;
            height: 100%;
        }
        textarea, #status, #foundHash {
            background-color: #000 !important;
            color: #ffffff;
            font-size: 0.85em;
            border-radius: 0;
            border: 1px solid #666666;
            padding: 10px;
            box-shadow: inset 0 0 20px #11111111;
            font-family: 'Share Tech Mono', monospace;
            width: calc(100% - 22px);
            margin: 0;
            outline: none;
        }
        textarea:focus, #foundHash:focus, #status:focus {
            border-color: #ffffff !important;
            box-shadow: 0 0 20px #ffffff33;
        }
        textarea[readonly] {
            resize: none;
            opacity: 0.9;
        }
        #status {
            font-weight: normal;
            color: #ffffff;
            border: 1px solid #666666;
            padding: 10px;
            min-height: 2em;
            box-shadow: inset 0 0 10px #11111111;
        }
        .success { 
            color: #ffffff !important; 
            text-shadow: 0 0 20px #ffffff; 
            animation: flicker 1s infinite;
        }
        .error { 
            color: #ff4444 !important; 
            border-color: #ff4444 !important; 
            text-shadow: 0 0 10px #ff4444; 
        }
        #foundHash { 
            font-size: 0.9em; 
            color: #ffffff; 
            word-break: break-all; 
        }
        ::selection { background: #ffffff33; color: #000; }
        ::-webkit-scrollbar { width: 6px; background: #000;}
        ::-webkit-scrollbar-thumb { background: #666666; }
        @media (max-width: 600px) {
            .container { padding: 10px; }
            .stats-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <div class="matrix-bg"></div>
    <div class="container">
        <div class="left-panel">
            <div class="panel">
                <h1>‚ü® BTC MINER ‚ü©</h1>
                <div class="subtitle">HASH CALCULATION SYSTEM v2.1</div>
                <button onclick="startMining()">‚ñ∫ INITIATE MINING SEQUENCE</button>
            </div>
            
            <div class="panel">
                <h3>‚ü© LIVE NONCE STREAM</h3>
                <div class="nonce-stream" id="nonceStream"></div>
            </div>
            
            <div class="panel">
                <h3>‚ü© BLOCK HEADER DATA</h3>
                <textarea id="blockHeader" readonly rows="8"></textarea>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="panel">
                <h3>‚ü© MINING METRICS</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Nonces Tested</div>
                        <div class="stat-value" id="stat_nonces">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Elapsed Time</div>
                        <div class="stat-value" id="stat_secs">0.00s</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Hash Rate</div>
                        <div class="stat-value" id="stat_speed">0 H/s</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Difficulty (Trillion)</div>
                        <div class="stat-value" id="stat_difficulty" style="font-size:1em;">-</div>
                    </div>
                    <div class="stat-box" style="grid-column: span 2;">
                        <div class="stat-label">Target Hash</div>
                        <div class="stat-value" id="stat_target" style="font-size:0.6em; word-break: break-all;">-</div>
                    </div>
                    <div class="stat-box" style="grid-column: span 2;">
                        <div class="stat-label">Lowest Hash Discovered</div>
                        <div class="stat-value" id="foundHash" style="font-size:0.6em; word-break: break-all;">-</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h3>‚ü© HASH RATE ANALYSIS</h3>
                <div class="chart-container">
                    <canvas id="hashRateChart"></canvas>
                </div>
            </div>
            
            <div class="panel">
                <h3>‚ü© SYSTEM STATUS</h3>
                <div id="status">System idle. Ready to initiate mining sequence.</div>
            </div>
        </div>
    </div>
    <script>
        // --- Chart setup ---
        let hashRateData = [];
        let maxDataPoints = 50;

        function initChart() {
            const canvas = document.getElementById('hashRateChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            return ctx;
        }

        function updateChart(ctx, data) {
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            if (data.length < 2) return;
            
            const max = Math.max(...data, 1);
            const step = width / (maxDataPoints - 1);
            
            // Draw grid
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const y = (height / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            
            for (let i = 0; i < data.length; i++) {
                const x = i * step;
                const y = height - (data[i] / max) * height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw points
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < data.length; i++) {
                const x = i * step;
                const y = height - (data[i] / max) * height;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Typing effect utility ---
        async function typeText(elem, text, delay=10, append=false) {
            if (!append) elem.textContent = '';
            for (let i = 0; i < text.length; i++) {
                elem.textContent += text[i];
                await new Promise(res => setTimeout(res, delay));
            }
        }

        // --- Nonce stream (replaces pop-up window) ---
        function logNonceToStream(nonce, hash, found) {
            const stream = document.getElementById('nonceStream');
            const line = document.createElement('div');
            line.className = 'nonce-line' + (found ? ' found' : '');
            line.textContent = `${nonce.toString().padStart(8, '0')}${hash ? ' : ' + hash.substring(0, 16) + '...' : ''}`;
            stream.appendChild(line);
            
            // Keep only last 500 lines
            while (stream.children.length > 500) {
                stream.removeChild(stream.firstChild);
            }
            
            // Auto-scroll
            stream.scrollTop = stream.scrollHeight;
        }

        function clearNonceStream() {
            document.getElementById('nonceStream').innerHTML = '';
        }

        function hexToBytes(hex) {
            if (hex.length % 2 !== 0) throw new Error("Hex string must have even length!");
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        }
        
        function bytesToHex(arr) {
            return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        function toLittleEndian(hex) {
            return hex.match(/../g).reverse().join('');
        }
        
        async function getLatestBlockHeader() {
            const chainInfoResp = await fetch('https://api.blockcypher.com/v1/btc/main');
            if (!chainInfoResp.ok) throw new Error('Could not fetch latest block hash');
            const chainInfo = await chainInfoResp.json();
            const blockHash = chainInfo.hash;
            const blockResp = await fetch('https://api.blockcypher.com/v1/btc/main/blocks/' + blockHash);
            if (!blockResp.ok) throw new Error('Could not fetch latest block data');
            const data = await blockResp.json();
            for (const key of ['ver', 'prev_block', 'mrkl_root', 'bits', 'time']) {
                if (data[key] === undefined || data[key] === null) {
                    throw new Error(`BlockCypher API missing ${key}. Block data: ${JSON.stringify(data, null, 2)}`);
                }
            }
            const unixTime = Math.floor(new Date(data.time).getTime() / 1000);
            return {
                ver: data.ver,
                prev_block: data.prev_block,
                mrkl_root: data.mrkl_root,
                time: unixTime,
                bits: data.bits,
                nonce: 0
            };
        }
        
        function bitsToTarget(bits) {
            let exponent = bits >>> 24;
            let mantissa = bits & 0xffffff;
            let target = BigInt(mantissa) * (2n ** (8n * (BigInt(exponent) - 3n)));
            return target;
        }
        
        function serializeBlockHeader(header) {
            for (let key of ['ver', 'prev_block', 'mrkl_root', 'time', 'bits', 'nonce']) {
                if (header[key] === undefined || header[key] === null) {
                    throw new Error(`Header field ${key} is undefined! Value: ` + header[key]);
                }
            }
            let hex = ''
                + toLittleEndian(header.ver.toString(16).padStart(8, '0'))
                + toLittleEndian(header.prev_block)
                + toLittleEndian(header.mrkl_root)
                + header.time.toString(16).padStart(8, '0')
                + header.bits.toString(16).padStart(8, '0')
                + header.nonce.toString(16).padStart(8, '0');
            return hexToBytes(hex);
        }
        
        async function doubleSHA256(buffer) {
            let hash1 = await crypto.subtle.digest('SHA-256', buffer);
            let hash2 = await crypto.subtle.digest('SHA-256', hash1);
            return bytesToHex(new Uint8Array(hash2));
        }

        async function broadcastBlock(header, winningHash) {
            const statusDiv = document.getElementById('status');
            
            try {
                // Create the full block header hex
                const blockHeaderHex = bytesToHex(serializeBlockHeader(header));
                
                statusDiv.textContent = 'üéâ VALID BLOCK FOUND! Attempting to broadcast to Bitcoin network...';
                
                // Try BlockCypher's broadcast endpoint
                const response = await fetch('https://api.blockcypher.com/v1/btc/main/txs/push', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tx: blockHeaderHex
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    statusDiv.textContent = `‚úÖ SUCCESS! Block broadcasted to network! Hash: ${winningHash}`;
                    console.log('Broadcast result:', result);
                } else {
                    const error = await response.text();
                    statusDiv.textContent = `‚ö†Ô∏è Block found but broadcast failed. You may need to use a full Bitcoin node. Hash: ${winningHash}`;
                    console.error('Broadcast error:', error);
                }
                
                // Also log the winning block details
                console.log('=== WINNING BLOCK DETAILS ===');
                console.log('Block Header Hex:', blockHeaderHex);
                console.log('Winning Nonce:', header.nonce);
                console.log('Winning Hash:', winningHash);
                console.log('You can manually broadcast this at: https://blockchair.com/broadcast');
                
            } catch (error) {
                statusDiv.textContent = `‚ö†Ô∏è Valid hash found but couldn't broadcast automatically. Hash: ${winningHash}`;
                console.error('Broadcast error:', error);
                console.log('Manual broadcast: Copy the block header from console and submit at blockchair.com/broadcast');
                console.log('Block Header:', bytesToHex(serializeBlockHeader(header)));
            }
        }

        // TEST FUNCTION - Run in console to simulate finding a block
        window.testBroadcast = async function() {
            console.log('üß™ TESTING BROADCAST FUNCTION...');
            console.log('Note: This will fail because we are using fake data, but you can see the flow');
            
            // Create a fake winning block header
            const fakeHeader = {
                ver: 536870912,
                prev_block: 'e'.repeat(64),
                mrkl_root: 'a'.repeat(64),
                time: Math.floor(Date.now() / 1000),
                bits: 386089497,
                nonce: 123456789
            };
            
            const fakeHash = '0'.repeat(64);
            
            console.log('Fake header created:', fakeHeader);
            console.log('Calling broadcastBlock...');
            
            await broadcastBlock(fakeHeader, fakeHash);
            
            console.log('‚úÖ Test complete! Check the status panel and console output above.');
            console.log('If you actually find a valid block, this same function will run automatically!');
        };
        
        console.log('testBroadcast()');


        // ---- Mining stats ---
        let miningStats = {
            startTimestamp: 0,
            elapsed: 0,
            tried: 0,
            speed: 0,
            lowestHash: null,
            lowestHashBigInt: null,
            target: null,
            difficulty: 0,
            updatesCount: 0
        };
        let statsInterval = null;
        let chartCtx = null;
        
        function resetStats() {
            miningStats = {startTimestamp: 0, elapsed: 0, tried: 0, speed: 0, lowestHash: null, lowestHashBigInt: null, target: null, difficulty: 0, updatesCount: 0};
            hashRateData = [];
            updateStatsPanel();
        }
        
        function updateStatsPanel() {
            document.getElementById('stat_nonces').textContent = miningStats.tried.toLocaleString();
            document.getElementById('stat_secs').textContent = miningStats.elapsed.toFixed(2) + "s";
            document.getElementById('stat_speed').textContent = miningStats.speed.toLocaleString() + " H/s";
            
            // Display full difficulty number (in trillions)
            document.getElementById('stat_difficulty').textContent = miningStats.difficulty ? miningStats.difficulty.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}) : "-";
            
            // Display full target hash
            if (miningStats.target) {
                const targetHex = miningStats.target.toString(16).padStart(64, '0');
                document.getElementById('stat_target').textContent = targetHex;
            } else {
                document.getElementById('stat_target').textContent = "-";
            }
            
            // Display lowest hash found
            if (miningStats.lowestHash) {
                document.getElementById('foundHash').textContent = miningStats.lowestHash;
            } else {
                document.getElementById('foundHash').textContent = "-";
            }
        }
        
        function startStatsTicker() {
            if (statsInterval) clearInterval(statsInterval);
            chartCtx = initChart();
            
            statsInterval = setInterval(() => {
                if (miningStats.startTimestamp)
                    miningStats.elapsed = (performance.now() - miningStats.startTimestamp)/1000;
                if (miningStats.elapsed > 0) {
                    miningStats.speed = Math.floor(miningStats.tried / miningStats.elapsed);
                    hashRateData.push(miningStats.speed);
                    if (hashRateData.length > maxDataPoints) hashRateData.shift();
                }
                updateStatsPanel();
                if (chartCtx) updateChart(chartCtx, hashRateData);
            }, 200);
        }
        
        function endStatsTicker() {
            if (statsInterval) clearInterval(statsInterval);
            statsInterval = null;
        }

        async function startMining() {
            clearNonceStream();
            
            const statusDiv = document.getElementById('status');
            const blockHeaderTextarea = document.getElementById('blockHeader');
            resetStats();
            statusDiv.className = '';
            await typeText(statusDiv, 'Fetching latest block data...', 8);
            document.getElementById('foundHash').textContent = '-';
            
            try {
                const header = await getLatestBlockHeader();
                await typeText(blockHeaderTextarea, JSON.stringify(header, null, 2), 2);
                await new Promise(res=>setTimeout(res,200));
                await typeText(statusDiv, 'Data fetched. Beginning hash calculation...', 8);
                const target = bitsToTarget(header.bits);
                miningStats.target = target;
                const targetNum = Number(target);
                const maxTarget = Number(0xFFFFn * (2n ** 208n));
                miningStats.difficulty = maxTarget / targetNum / 1e12;

                let nonce = 0, stop = false;
                miningStats.startTimestamp = performance.now();
                miningStats.elapsed = 0;
                miningStats.tried = 0;
                miningStats.speed = 0;
                miningStats.lowestHash = null;
                miningStats.lowestHashBigInt = null;
                miningStats.updatesCount = 0;
                updateStatsPanel();
                startStatsTicker();

                async function mineChunk(firstRun = false) {
                    const chunkSize = firstRun ? 500000 : 100000; // Larger first chunk
                    for (let i = 0; i < chunkSize && !stop; ++i, ++nonce) {
                        header.nonce = nonce;
                        let raw = serializeBlockHeader(header);
                        let hashHex = await doubleSHA256(raw);
                        let reversedHash = toLittleEndian(hashHex);
                        let hashNum = BigInt('0x' + reversedHash);
                        
                        // Log every 100th nonce to stream
                        if (nonce % 100 === 0) {
                            logNonceToStream(nonce, reversedHash, hashNum < target);
                        }

                        // Update lowest hash - check if this is lower than current best
                        if (miningStats.lowestHashBigInt === null || hashNum < miningStats.lowestHashBigInt) {
                            miningStats.lowestHash = reversedHash;
                            miningStats.lowestHashBigInt = hashNum;
                            miningStats.updatesCount++;
                            // Log to console for debugging
                            if (miningStats.updatesCount <= 50) {
                                console.log(`Update #${miningStats.updatesCount} at nonce ${nonce}: ${reversedHash.substring(0, 16)}...`);
                            }
                        }
                        
                        miningStats.tried = nonce;

                        if (hashNum < target) {
                            endStatsTicker();
                            statusDiv.className = 'success';
                            await typeText(statusDiv, `>>> SUCCESS! VALID HASH FOUND AT NONCE: ${nonce.toLocaleString()} <<<`, 12);
                            logNonceToStream(nonce, reversedHash, true);
                            updateStatsPanel();
                            
                            // Attempt to broadcast the winning block
                            await broadcastBlock(header, reversedHash);
                            return;
                        }
                        
                        // Update display less frequently for better performance
                        if (nonce % 500 === 0) {
                            statusDiv.className = '';
                            statusDiv.textContent = `Mining... Nonce: ${nonce.toLocaleString()}`;
                            // Allow UI to update
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    if (!stop) {
                        endStatsTicker();
                        updateStatsPanel();
                        let cont = confirm(`Searched ${nonce.toLocaleString()} nonces. Continue mining next 100,000?`);
                        if (cont) {
                            miningStats.startTimestamp = performance.now() - miningStats.elapsed*1000;
                            startStatsTicker();
                            mineChunk(false);
                        } else {
                            statusDiv.textContent = `Stopped at nonce ${nonce.toLocaleString()}.`;
                            statusDiv.className = '';
                        }
                    }
                }
                mineChunk(true);
            } catch (error) {
                endStatsTicker();
                statusDiv.textContent = 'Error: ' + error.message;
                statusDiv.className = 'error';
            }
        }
    </script>
</body>
</html>